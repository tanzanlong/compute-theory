### 实现要求

实现必须符合以下要求：

1. 使用尽力而为的领导者选举算法，从算法服务器中选出具有最新历史记录的领导者。
2. 观察员或追随者一次只能连接到一个领导。
3. 服务器必须按照收到的顺序处理数据包。由于TCP在发送数据包时保持排序，这意味着数据包将按照发送者定义的顺序进行处理。

### 领导选举

  所有服务器开始寻找领导者。一旦给定服务器上的领导者选举实例，表明领导者已经出现，它将移动到阶段1.如果领导者选举实例指示服务器是领导者，则其作为领导者移动到阶段1，否则移动到阶段1作为追随者。 



### 第一阶段：epoch的建立

  在这个阶段，当选的领导者确保以前的领导者不能提交新的提案并决定最初的历史。（注意领导也被认为是自己的追随者。）

 任何失败或超时都将导致服务器返回领导者选举。

1. **升**领导开始接受来自信徒的连接。

2. **f**追随者连接领导者并发送FOLLOWERINFO。

3. **l**一旦领导者达到法定人数，它将停止接受连接，并将LEADERINFO（e）发送给所有追随者，其中e大于法定人数中所有**f。**接受的时间。

4. f

   当追随者收到LEADERINFO（e）时，它将执行以下操作之一：

   - 如果e> **f。**接受的Epoch，跟随者设置**f** .acceptedEpoch = e并发送ACKEPOCH（e）;
   - 如果e == **f** .acceptedEpoch，跟随者不发送ACKEPOCH，但继续下一步;
   - 如果e < **f。**接受的时代，追随者关闭与领导者的联系并返回领导者选举;

5. **l**领导等待法定人数发送ACKEPOCH。

6. l

   如果所有连接的追随者都不符合以下条件，领导者会断开追随者并返回领导者选举：

   - **˚F** .currentEpoch <= **升** .currentEpoch
   - 如果**˚F** .currentEpoch == **升** .currentEpoch，然后**˚F** .lastZxid <= **升** .lastZxid

请注意，如果跟随者连接，但领导者已经建立（在阶段3），跟随者会跟随阶段，但领导者忽略任何ACK。

在第1阶段的描述与[http://research.yahoo.com/files/YL-2010-007.pdf中的](http://research.yahoo.com/files/YL-2010-007.pdf:)描述之间有两个明显的区别  [：](http://research.yahoo.com/files/YL-2010-007.pdf:)

1. 领导者不会与最新的跟随者同步
2. 追随者不会在NEWEPOCH消息的ACK中发送其历史记录。

我们使用的领导者选举协议试图保证选举出来的领导者拥有最多的法定流程历史。他们也试图保证只有一名选举产生的领导人。这些担保可能因竞争条件，陈旧信息或甚至实施错误而不能成立，因此我们确保担保在第一阶段得到满足。在技术报告中，我们并不认为当选领导者拥有最新的历史，所以我们必须找到最新的跟随者并与之同步。然而，由于当选领导者应该是最新的过程，使用我们使用的领导选举协议，我们只需在步骤7中检查条件。如果领导者符合步骤7的条件，我们是最适合的-日期，所以我们已经隐含地与法定人数中的最新流程同步。如果没有，我们会回到领导人选举。

与技术报告中描述的协议的另一个区别是在LearnerInfo和FollowerInfo中发送的额外信息。额外的信息用于实现目的：确保协议版本在客户端和服务器之间兼容，以及用于调试目的的信息。



### 第二阶段：与followers信息同步

1. l

   领导者在与每个跟随者连接的情况下执行以下操作：

   1. 将追随者添加到连接列表中以发送新建议，因此，在服务器执行下一步骤时，它将排队发送给追随者的任何新建议。
   2. 执行以下操作之一：
      - SNAP如果追随者远远落后于执行州转移比发送缺失交易更好。
      - TRUNC（*zxid*）如果追随者有领导选择跳过的交易。领导者将zxid设置为追随者历史上的最后一个*zxid*。然后领导发送追随者失踪的交易。
      - DIFF如果领导者发送追随者失踪的交易。领导发送丢失的消息给追随者。
   3. 发送NEWLEADER（*e*）;
   4. 领导发布任何排队的消息给追随者。

2. **f**跟随者与领导者同步，但在接收到NEWLEADER（*e*）数据包之前不会修改其状态。一旦它接收到NEWLEADER（*e*），它会自动应用新状态并设置**f** .currentEpoch = *e*。然后它发送ACK（*e* << 32）。

3. **升**一旦领导者已收到确认与追随者的法定人数，需要划时代的领导*Ë*和队列UPTODATE所有的追随者。

4. **f**当追随者收到UPDATE消息时，它开始接受客户端连接并提供新的状态。

5. **升**领袖重新开始接受来自信徒的连接。变量nextZxid设置为（*e* << 32）+ 1。

### 第三阶段：与followers信息同步

   领导者和追随者可以在流程中以及处于不同阶段的多个提案。只要有一定数量的追随者在超时间隔内确认其提案或ping，领导者就会保持活跃。只要在超时间隔内收到提案或ping，追随者就会继续支持领导。任何失败或超时都会导致服务器返回到领导者选举。

1. **l**领导将一个数据包PROPOSE（zxid，data）（其中zxid = nextZxid）排队到所有连接的跟随者。它增加nextZxid。
2. **˚F**从动将记录和同步提案到磁盘并发送ACK（zxid）。
3. **l**当领导从法定的追随者收到确认时，它将COMMIT（zxid）排队给所有追随者。

https://blog.csdn.net/gs80140/article/details/51496925

https://cwiki.apache.org/confluence/display/ZOOKEEPER/Zab1.0